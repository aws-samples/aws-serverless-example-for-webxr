"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.handler=exports.invoke=void 0;const client_lambda_1=require("@aws-sdk/client-lambda"),node_http_handler_1=require("@aws-sdk/node-http-handler"),decodePayload=payload=>{if(payload)return new TextDecoder().decode(Buffer.from(payload))},invoke=async(functionName,invocationType,timeout)=>{const lambda=new client_lambda_1.Lambda({requestHandler:new node_http_handler_1.NodeHttpHandler({socketTimeout:timeout})}),invokeRequest={FunctionName:functionName,InvocationType:invocationType};console.log({invokeRequest});let retryCount=0;const delay=5e3;let rawResponse;for(;;)try{rawResponse=await lambda.invoke(invokeRequest);break}catch(error){if(error.name==="AccessDeniedException"&&retryCount<12){retryCount++,await new Promise(resolve=>{setTimeout(resolve,delay)});continue}throw error}const invokeResponse={...rawResponse,Payload:decodePayload(rawResponse.Payload)};return console.log({invokeResponse}),invokeResponse};exports.invoke=invoke;async function handler(event){if(console.log({...event,ResponseURL:"..."}),event.RequestType==="Delete"){console.log("not calling trigger on DELETE");return}if(event.RequestType==="Update"&&event.ResourceProperties.ExecuteOnHandlerChange==="false"){console.log("not calling trigger because ExecuteOnHandlerChange is false");return}const handlerArn=event.ResourceProperties.HandlerArn;if(!handlerArn)throw new Error('The "HandlerArn" property is required');const invocationType=event.ResourceProperties.InvocationType,timeout=event.ResourceProperties.Timeout,parsedTimeout=parseInt(timeout);if(isNaN(parsedTimeout))throw new Error(`The "Timeout" property with value ${timeout} is not parsable to a number`);const invokeResponse=await(0,exports.invoke)(handlerArn,invocationType,parsedTimeout);if(invokeResponse.StatusCode&&invokeResponse.StatusCode>=400)throw new Error(`Trigger handler failed with status code ${invokeResponse.StatusCode}`);if(invokeResponse.FunctionError)throw new Error(parseError(invokeResponse.Payload))}exports.handler=handler;function parseError(payload){if(!payload)return"unknown handler error";console.log(`Error payload: ${payload}`);try{const error=JSON.parse(payload),concat=[error.errorMessage,error.trace].filter(x=>x).join(`
`);return concat.length>0?concat:payload}catch{return payload}}
